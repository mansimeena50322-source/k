#include "IODeviceDriver.hpp"

// Pin constants (matching enum order)
static const uint8_t nRST_PIN    = PIN_nRST;
static const uint8_t nTEST_PIN   = PIN_nTEST;
static const uint8_t DONE_PIN    = PIN_DONE;
static const uint8_t SUCCESS_PIN = PIN_SUCCESS;
static const uint8_t CTRL_PIN    = PIN_CTRL;
static const uint8_t SELECT_PIN  = PIN_SELECT;

// ---------------- Constructor ----------------
IODeviceDriver::IODeviceDriver() {
    // Configure pin directions
    set_pin_mode(nRST_PIN, 2);     // open drain + pullup
    set_pin_mode(CTRL_PIN, 2);     // open drain + pullup
    set_pin_mode(nTEST_PIN, 1);    // output
    set_pin_mode(SELECT_PIN, 1);   // output
    set_pin_mode(DONE_PIN, 0);     // input
    set_pin_mode(SUCCESS_PIN, 0);  // input

    // Initial states
    set_pin_output(nRST_PIN, 0);   // device in reset
    set_pin_output(nTEST_PIN, 1);  // always high
    set_pin_output(SELECT_PIN, 0); // not selected
}

// ---------------- Helpers ----------------
void IODeviceDriver::enter_config(ConfigMode mode) {
    // Select device
    set_pin_output(SELECT_PIN, 1);

    // Select configuration mode
    if (mode == MODE_0)
        set_pin_output(CTRL_PIN, 0); // Mode 0
    else
        set_pin_output(CTRL_PIN, 1); // Mode 1 or 2

    // Reset low then high (posedge nRST = enter config)
    set_pin_output(nRST_PIN, 0);
    delay_ms(10);
    set_pin_output(nRST_PIN, 1);
}

void IODeviceDriver::exit_config() {
    // Deselect device
    set_pin_output(SELECT_PIN, 0);
    // Return to reset
    set_pin_output(nRST_PIN, 0);
    // Default idle CTRL (high)
    set_pin_output(CTRL_PIN, 1);
}

IODeviceDriver::ConfigResult IODeviceDriver::wait_for_done(uint32_t max_wait_ms) {
    for (uint32_t i = 0; i < max_wait_ms; ++i) {
        if (read_pin_input(DONE_PIN)) {
            if (read_pin_input(SUCCESS_PIN))
                return SUCCESS_NO_ERROR;
            else
                return FAILURE_ERROR;
        }
        delay_ms(1);
    }
    return FAILURE_TIMEOUT;
}

// ---------------- Mode Implementations ----------------

// Mode 0: Communication mode
IODeviceDriver::ConfigResult IODeviceDriver::configure_mode_0(const uint8_t* data, size_t size) {
    enter_config(MODE_0);

    // Minimum required communication time (ms)
    uint32_t min_comm_ms = static_cast<uint32_t>((1 + size * 8) / 1000.0);
    if (min_comm_ms < 1) min_comm_ms = 1; // enforce minimal delay

    delay_ms(min_comm_ms);  // simulate COMS active period

    // Max wait = 2x communication time
    ConfigResult result = wait_for_done(min_comm_ms * 2);

    exit_config();
    return result;
}

// Mode 1: External control <100ms
IODeviceDriver::ConfigResult IODeviceDriver::configure_mode_1() {
    enter_config(MODE_1);

    // Release CTRL line (OD = high)
    set_pin_output(CTRL_PIN, 1);

    ConfigResult result = wait_for_done(100); // <100ms

    exit_config();
    return result;
}

// Mode 2: External control on both CTRL and nRST <200ms
IODeviceDriver::ConfigResult IODeviceDriver::configure_mode_2() {
    enter_config(MODE_2);

    // Release both OD pins
    set_pin_output(nRST_PIN, 1);
    set_pin_output(CTRL_PIN, 1);

    ConfigResult result = wait_for_done(200); // <200ms

    exit_config();
    return result;
}
